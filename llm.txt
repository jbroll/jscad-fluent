# jscad-fluent API

Fluent wrapper for JSCAD. All methods chainable. REQUIRE NOT IMPORT: `const jf = require('@jbroll/jscad-fluent')
`

## CRITICAL CONSTRAINTS
- Angles: RADIANS (not degrees). Use Math.PI
- Colors: 0-1 range (not 0-255)
- Booleans: all inputs must be same type (all 2D or all 3D)
- All operations return NEW objects (immutable, like standard JSCAD)
- Measurements return values (not chainable)

## TYPES
```
Vec2 = [number, number]
Vec3 = [number, number, number]
RGB = [number, number, number]        // 0-1
RGBA = [number, number, number, number]  // 0-1
Corners = 'edge' | 'chamfer' | 'round'
```

## 2D PRIMITIVES -> FluentGeom2

jf.rectangle({ size?: Vec2=[2,2], center?: Vec2=[0,0] })
jf.roundedRectangle({ size?: Vec2=[2,2], center?: Vec2=[0,0], roundRadius?: number=0.2, segments?: number=32 })
jf.square({ size?: number=2, center?: Vec2=[0,0] })
jf.circle({ radius?: number=1, center?: Vec2=[0,0], startAngle?: number=0, endAngle?: number=2*PI, segments?: number=32 })
jf.ellipse({ radius?: Vec2=[1,1], center?: Vec2=[0,0], startAngle?: number=0, endAngle?: number=2*PI, segments?: number=32 })
jf.polygon(points: Vec2[])  // counter-clockwise for extrusion
jf.star({ vertices?: number=5, outerRadius?: number=1, innerRadius?: number=0, density?: number=2, startAngle?: number=0, center?: Vec2=[0,0] })
jf.triangle({ type?: 'SSS'|'AAS'|'ASA'|'SAS'|'SSA'='SSS', values?: [number,number,number]=[1,1,1] })  // A=angle (radians), S=side length

## PATH PRIMITIVES -> FluentPath2

jf.arc({ center?: Vec2=[0,0], radius?: number=1, startAngle?: number=0, endAngle?: number=2*PI, segments?: number=32, makeTangent?: boolean=false })
jf.line(points: Vec2[])

## 3D PRIMITIVES -> FluentGeom3

jf.cube({ size?: number=2, center?: Vec3=[0,0,0] })
jf.cuboid({ size?: Vec3=[2,2,2], center?: Vec3=[0,0,0] })
jf.sphere({ radius?: number=1, center?: Vec3=[0,0,0], segments?: number=32 })
jf.cylinder({ radius?: number=1, height?: number=2, center?: Vec3=[0,0,0], segments?: number=32 })
jf.cylinderElliptic({ height?: number=2, startRadius?: Vec2=[1,1], endRadius?: Vec2=[1,1], startAngle?: number=0, endAngle?: number=2*PI, center?: Vec3=[0,0,0], segments?: number=32 })
jf.torus({ innerRadius?: number=1, outerRadius?: number=4, innerSegments?: number=32, outerSegments?: number=32, innerRotation?: number=0, outerRotation?: number=2*PI, startAngle?: number=0 })
jf.ellipsoid({ radius?: Vec3=[1,1,1], center?: Vec3=[0,0,0], segments?: number=32, axes?: [Vec3,Vec3,Vec3] })
jf.geodesicSphere({ radius?: number=1, frequency?: number=6 })  // frequency: multiples of 6
jf.roundedCuboid({ size?: Vec3=[2,2,2], center?: Vec3=[0,0,0], roundRadius?: number=0.2, segments?: number=32 })
jf.roundedCylinder({ radius?: number=1, height?: number=2, center?: Vec3=[0,0,0], roundRadius?: number=0.2, segments?: number=32 })
jf.polyhedron({ points: Vec3[], faces: number[][], colors?: RGBA[], orientation?: 'outward'|'inward'='outward' })

## TRANSFORMS -> new instance (chainable, all geometry types)

.translate(offset: Vec3)
.translateX(offset: number)
.translateY(offset: number)
.translateZ(offset: number)
.rotate(angles: Vec3)           // radians [rx, ry, rz]
.rotateX(angle: number)         // radians
.rotateY(angle: number)         // radians
.rotateZ(angle: number)         // radians
.scale(factors: Vec3)
.scaleX(factor: number)
.scaleY(factor: number)
.scaleZ(factor: number)
.mirror({ origin?: Vec3=[0,0,0], normal?: Vec3=[0,0,1] })
.mirrorX()                      // across YZ plane
.mirrorY()                      // across XZ plane
.mirrorZ()                      // across XY plane
.center({ axes?: [bool,bool,bool]=[true,true,true], relativeTo?: Vec3=[0,0,0] })
.centerX()
.centerY()
.centerZ()
.transform(matrix: Mat4)

## COLOR -> new instance

.colorize(color: RGB | RGBA)    // values 0-1

## COLOR UTILITIES (jf.colors.*)

jf.colors.hexToRgb(hex: string) -> RGB | RGBA       // '#FF0000', '#F00', '#FF000080'
jf.colors.colorNameToRgb(name: string) -> RGB       // 'red', 'lightblue', 'cornflowerblue'
jf.colors.hslToRgb(hsl: [h,s,l]) -> RGB             // all values 0-1
jf.colors.hsvToRgb(hsv: [h,s,v]) -> RGB             // all values 0-1
jf.colors.rgbToHex(rgb: RGB) -> string              // returns '#ff0000'
jf.colors.rgbToHsl(rgb: RGB) -> [h,s,l]
jf.colors.rgbToHsv(rgb: RGB) -> [h,s,v]
jf.colors.css.<name>                                // 150+ CSS colors: .red, .lightblue, etc.

## BOOLEANS -> new instance (inputs must match geometry type)

// Method chaining - accepts spread args, arrays, or mixed
.union(...others)           // a.union(b), a.union(b, c), a.union([b, c])
.subtract(...others)        // a.subtract(b), a.subtract(b, c), a.subtract([b, c])
.intersect(...others)       // a.intersect(b), a.intersect(b, c), a.intersect([b, c])

// Top-level functions - for combining multiple geometries
jf.union(...geometries)     // jf.union(a, b, c), jf.union([a, b, c])
jf.subtract(...geometries)  // jf.subtract(base, hole1, hole2), jf.subtract(base, [holes])
jf.intersect(...geometries) // jf.intersect(a, b, c), jf.intersect([a, b, c])

## HULL -> new instance

.hull()
.hullChain()

## EXPANSION -> new instance

.expand({ delta?: number=1, corners?: Corners='edge', segments?: number=16 })
.offset({ delta?: number=1, corners?: Corners='edge', segments?: number=16 })  // 2D only

## EXTRUSION (FluentGeom2 -> FluentGeom3)

.extrudeLinear({ height?: number=1, twistAngle?: number=0, twistSteps?: number=1 })
.extrudeRotate({ angle?: number=2*PI, startAngle?: number=0, segments?: number=12, overflow?: 'cap'='cap' })

## MEASUREMENTS -> values (not chainable)

.measureBoundingBox() -> [[minX,minY,minZ], [maxX,maxY,maxZ]]
.measureBoundingSphere() -> [centroid: Vec3, radius: number]
.measureCenter() -> Vec3
.measureDimensions() -> [width, depth, height]
.measureArea() -> number        // 2D only
.measureVolume() -> number      // 3D only

## UTILITY

.validate() -> void             // throws if invalid
.toString() -> string
.toPoints() -> Vec2[]           // 2D only
.toOutlines() -> Vec2[][]       // 2D only
.toPolygons() -> {vertices: Vec3[]}[]  // 3D only
.append(geometry) -> FluentGeom2Array | FluentGeom3Array

## EXAMPLE

```javascript
const jf = require('@jbroll/jscad-fluent');

const model = jf.rectangle({ size: [50, 30] })
  .subtract(jf.circle({ radius: 8 }).translate([15, 0, 0]))
  .expand({ delta: 2, corners: 'round' })
  .extrudeLinear({ height: 20 })
  .union(jf.cylinder({ radius: 3, height: 25 }).translate([20, 10, 0]))
  .colorize(jf.colors.hexToRgb('#3344CC'));

// Multiple objects at once
const holes = [
  jf.cylinder({ radius: 2, height: 10 }).translate([5, 5, 0]),
  jf.cylinder({ radius: 2, height: 10 }).translate([-5, -5, 0])
];
const withHoles = block.subtract(holes);  // array form
const withHoles2 = block.subtract(hole1, hole2);  // spread form

// Top-level union for combining many objects
const allParts = jf.union(part1, part2, part3);
const allParts2 = jf.union([part1, part2, part3]);  // array form

// Or use CSS color names
const redSphere = jf.sphere({ radius: 5 }).colorize(jf.colors.css.red);
```
